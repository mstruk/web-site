<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_20-ea) on Fri Jan 09 18:07:25 GMT 2015 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>io.vertx.core.streams (Vert.x Core 3.0.0-SNAPSHOT API)</title>
<meta name="date" content="2015-01-09">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="io.vertx.core.streams (Vert.x Core 3.0.0-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/vertx/core/spi/cluster/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../io/vertx/core/streams/impl/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/vertx/core/streams/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;io.vertx.core.streams</h1>
<div class="docSummary">
<div class="block">There are several objects in Vert.x that allow items to be read from and written.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/streams/Pump.html" title="interface in io.vertx.core.streams">Pump</a></td>
<td class="colLast">
<div class="block">Pumps data from a <a href="../../../../io/vertx/core/streams/ReadStream.html" title="interface in io.vertx.core.streams"><code>ReadStream</code></a> to a <a href="../../../../io/vertx/core/streams/WriteStream.html" title="interface in io.vertx.core.streams"><code>WriteStream</code></a> and performs flow control where necessary to
 prevent the write stream buffer from getting overfull.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../io/vertx/core/streams/ReadStream.html" title="interface in io.vertx.core.streams">ReadStream</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">Represents a stream of data that can be read from.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/streams/StreamBase.html" title="interface in io.vertx.core.streams">StreamBase</a></td>
<td class="colLast">
<div class="block">Represents a stream of data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../io/vertx/core/streams/WriteStream.html" title="interface in io.vertx.core.streams">WriteStream</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">Represents a stream of data that can be written to</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package io.vertx.core.streams Description">Package io.vertx.core.streams Description</h2>
<div class="block">There are several objects in Vert.x that allow items to be read from and written. In previous versions the
 <a href="../../../../io/vertx/core/streams/package-summary.html"><code>io.vertx.core.streams</code></a> package was manipulating <a href="../../../../io/vertx/core/buffer/Buffer.html" title="interface in io.vertx.core.buffer"><code>Buffer</code></a> objects exclusively.
 From now, streams are not anymore coupled to buffers and work with any kind of objects.

 In Vert.x, calls to write item return immediately and writes are internally queued.

 It's not hard to see that if you write to an object faster than it can actually write the data to
 its underlying resource then the write queue could grow without bound - eventually resulting in
 exhausting available memory.

 To solve this problem a simple flow control capability is provided by some objects in the Vert.x API.

 Any flow control aware object that can be written-to implements <a href="../../../../io/vertx/core/streams/ReadStream.html" title="interface in io.vertx.core.streams"><code>ReadStream</code></a>,
 and any flow control object that can be read-from is said to implement <a href="../../../../io/vertx/core/streams/WriteStream.html" title="interface in io.vertx.core.streams"><code>WriteStream</code></a>.

 Let's take an example where we want to read from a `ReadStream` and write the data to a `WriteStream`.

 A very simple example would be reading from a <a href="../../../../io/vertx/core/net/NetSocket.html" title="interface in io.vertx.core.net"><code>NetSocket</code></a> on a server and writing back to the
 same `NetSocket` - since `NetSocket` implements both `ReadStream` and `WriteStream`, but you can
 do this between any `ReadStream` and any `WriteStream`, including HTTP requests and response,
 async files, WebSockets, etc.

 A naive way to do this would be to directly take the data that's been read and immediately write it
 to the `NetSocket`, for example:

 [source,java]
 ----
 <a href="../../../../examples/StreamsExamples.html#pump1-io.vertx.core.Vertx-"><code>StreamsExamples.pump1(io.vertx.core.Vertx)</code></a>
 ----

 There's a problem with the above example: If data is read from the socket faster than it can be
 written back to the socket, it will build up in the write queue of the `NetSocket`, eventually
 running out of RAM. This might happen, for example if the client at the other end of the socket
 wasn't reading very fast, effectively putting back-pressure on the connection.

 Since `NetSocket` implements `WriteStream`, we can check if the `WriteStream` is full before
 writing to it:

 [source,java]
 ----
 <a href="../../../../examples/StreamsExamples.html#pump2-io.vertx.core.Vertx-"><code>StreamsExamples.pump2(io.vertx.core.Vertx)</code></a>
 ----

 This example won't run out of RAM but we'll end up losing data if the write queue gets full. What we
 really want to do is pause the `NetSocket` when the write queue is full. Let's do that:

 [source,java]
 ----
 <a href="../../../../examples/StreamsExamples.html#pump3-io.vertx.core.Vertx-"><code>StreamsExamples.pump3(io.vertx.core.Vertx)</code></a>
 ----

 We're almost there, but not quite. The `NetSocket` now gets paused when the file is full, but we also need to unpause
 it when the write queue has processed its backlog:

 [source,java]
 ----
 <a href="../../../../examples/StreamsExamples.html#pump4-io.vertx.core.Vertx-"><code>StreamsExamples.pump4(io.vertx.core.Vertx)</code></a>
 ----

 And there we have it. The <a href="../../../../io/vertx/core/streams/WriteStream.html#drainHandler-io.vertx.core.Handler-"><code>WriteStream.drainHandler(io.vertx.core.Handler&lt;java.lang.Void&gt;)</code></a> event handler will
 get called when the write queue is ready to accept more data, this resumes the `NetSocket` which
 allows it to read more data.

 It's very common to want to do this when writing Vert.x applications, so we provide a helper class
 called <a href="../../../../io/vertx/core/streams/Pump.html" title="interface in io.vertx.core.streams"><code>Pump</code></a> which does all this hard work for you. You just feed it the `ReadStream` and
 the `WriteStream` and it tell it to start:

 [source,java]
 ----
 <a href="../../../../examples/StreamsExamples.html#pump5-io.vertx.core.Vertx-"><code>StreamsExamples.pump5(io.vertx.core.Vertx)</code></a>
 ----

 Which does exactly the same thing as the more verbose example.

 Let's look at the methods on `ReadStream` and `WriteStream` in more detail:

 === ReadStream

 `ReadStream` is implemented by <a href="../../../../io/vertx/core/http/HttpClientResponse.html" title="interface in io.vertx.core.http"><code>HttpClientResponse</code></a>, <a href="../../../../io/vertx/core/datagram/DatagramSocket.html" title="interface in io.vertx.core.datagram"><code>DatagramSocket</code></a>,
 <a href="../../../../io/vertx/core/http/HttpClientRequest.html" title="interface in io.vertx.core.http"><code>HttpClientRequest</code></a>, <a href="../../../../io/vertx/core/http/HttpServerFileUpload.html" title="interface in io.vertx.core.http"><code>HttpServerFileUpload</code></a>,
 <a href="../../../../io/vertx/core/http/HttpServerRequest.html" title="interface in io.vertx.core.http"><code>HttpServerRequest</code></a>, <a href="../../../../io/vertx/core/http/HttpServerRequestStream.html" title="interface in io.vertx.core.http"><code>HttpServerRequestStream</code></a>,
 <a href="../../../../io/vertx/core/eventbus/MessageConsumer.html" title="interface in io.vertx.core.eventbus"><code>MessageConsumer</code></a>, <a href="../../../../io/vertx/core/net/NetSocket.html" title="interface in io.vertx.core.net"><code>NetSocket</code></a>, <a href="../../../../io/vertx/core/net/NetSocketStream.html" title="interface in io.vertx.core.net"><code>NetSocketStream</code></a>,
 <a href="../../../../io/vertx/core/http/WebSocket.html" title="interface in io.vertx.core.http"><code>WebSocket</code></a>, <a href="../../../../io/vertx/core/http/WebSocketStream.html" title="interface in io.vertx.core.http"><code>WebSocketStream</code></a>, <a href="../../../../io/vertx/core/TimeoutStream.html" title="interface in io.vertx.core"><code>TimeoutStream</code></a>,
 <a href="../../../../io/vertx/core/file/AsyncFile.html" title="interface in io.vertx.core.file"><code>AsyncFile</code></a>.

 Functions:

 - <a href="../../../../io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-"><code>ReadStream.handler(io.vertx.core.Handler&lt;T&gt;)</code></a>:
 set a handler which will receive items from the ReadStream.
 - <a href="../../../../io/vertx/core/streams/ReadStream.html#pause--"><code>ReadStream.pause()</code></a>:
 pause the handler. When paused no items will be received in the handler.
 - <a href="../../../../io/vertx/core/streams/ReadStream.html#resume--"><code>ReadStream.resume()</code></a>:
 resume the handler. The handler will be called if any item arrives.
 - <a href="../../../../io/vertx/core/streams/ReadStream.html#exceptionHandler-io.vertx.core.Handler-"><code>ReadStream.exceptionHandler(io.vertx.core.Handler&lt;java.lang.Throwable&gt;)</code></a>:
 Will be called if an exception occurs on the ReadStream.
 - <a href="../../../../io/vertx/core/streams/ReadStream.html#endHandler-io.vertx.core.Handler-"><code>ReadStream.endHandler(io.vertx.core.Handler&lt;java.lang.Void&gt;)</code></a>:
 Will be called when end of stream is reached. This might be when EOF is reached if the ReadStream represents a file,
 or when end of request is reached if it's an HTTP request, or when the connection is closed if it's a TCP socket.

 === WriteStream

 `WriteStream` is implemented by <a href="../../../../io/vertx/core/http/HttpClientRequest.html" title="interface in io.vertx.core.http"><code>HttpClientRequest</code></a>, <a href="../../../../io/vertx/core/http/HttpServerResponse.html" title="interface in io.vertx.core.http"><code>HttpServerResponse</code></a>
 <a href="../../../../io/vertx/core/http/WebSocket.html" title="interface in io.vertx.core.http"><code>WebSocket</code></a>, <a href="../../../../io/vertx/core/net/NetSocket.html" title="interface in io.vertx.core.net"><code>NetSocket</code></a>, <a href="../../../../io/vertx/core/file/AsyncFile.html" title="interface in io.vertx.core.file"><code>AsyncFile</code></a>,
 <a href="../../../../io/vertx/core/datagram/PacketWritestream.html" title="interface in io.vertx.core.datagram"><code>PacketWritestream</code></a> and <a href="../../../../io/vertx/core/eventbus/MessageProducer.html" title="interface in io.vertx.core.eventbus"><code>MessageProducer</code></a>

 Functions:

 - <a href="../../../../io/vertx/core/streams/WriteStream.html#write-T-"><code>WriteStream.write(T)</code></a>:
 write an object to the WriteStream. This method will never block. Writes are queued internally and asynchronously
 written to the underlying resource.
 - <a href="../../../../io/vertx/core/streams/WriteStream.html#setWriteQueueMaxSize-int-"><code>WriteStream.setWriteQueueMaxSize(int)</code></a>:
 set the number of object at which the write queue is considered _full_, and the method <a href="../../../../io/vertx/core/streams/WriteStream.html#writeQueueFull--"><code>WriteStream.writeQueueFull()</code></a>
 returns `true`. Note that, when the write queue is considered full, if write is called the data will still be accepted
 and queued. The actual number depends on the stream implementation, for <a href="../../../../io/vertx/core/buffer/Buffer.html" title="interface in io.vertx.core.buffer"><code>Buffer</code></a> the size
 represents the actual number of bytes written and not the number of buffers.
 - <a href="../../../../io/vertx/core/streams/WriteStream.html#writeQueueFull--"><code>WriteStream.writeQueueFull()</code></a>:
 returns `true` if the write queue is considered full.
 - <a href="../../../../io/vertx/core/streams/WriteStream.html#exceptionHandler-io.vertx.core.Handler-"><code>WriteStream.exceptionHandler(io.vertx.core.Handler&lt;java.lang.Throwable&gt;)</code></a>:
 Will be called if an exception occurs on the `WriteStream`.
 - <a href="../../../../io/vertx/core/streams/WriteStream.html#drainHandler-io.vertx.core.Handler-"><code>WriteStream.drainHandler(io.vertx.core.Handler&lt;java.lang.Void&gt;)</code></a>:
 The handler will be called if the `WriteStream` is considered no longer full.

 === Pump

 Instances of Pump have the following methods:

 - <a href="../../../../io/vertx/core/streams/Pump.html#start--"><code>Pump.start()</code></a>:
 Start the pump.
 - <a href="../../../../io/vertx/core/streams/Pump.html#stop--"><code>Pump.stop()</code></a>:
 Stops the pump. When the pump starts it is in stopped mode.
 - <a href="../../../../io/vertx/core/streams/Pump.html#setWriteQueueMaxSize-int-"><code>Pump.setWriteQueueMaxSize(int)</code></a>:
 This has the same meaning as <a href="../../../../io/vertx/core/streams/WriteStream.html#setWriteQueueMaxSize-int-"><code>WriteStream.setWriteQueueMaxSize(int)</code></a> on the `WriteStream`.

 A pump can be started and stopped multiple times.

 When a pump is first created it is _not_ started. You need to call the `start()` method to start it.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd><a href="mailto:julien@julienviet.com">Julien Viet</a></dd>
</dl>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/vertx/core/spi/cluster/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../io/vertx/core/streams/impl/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/vertx/core/streams/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2015. All rights reserved.</small></p>
</body>
</html>

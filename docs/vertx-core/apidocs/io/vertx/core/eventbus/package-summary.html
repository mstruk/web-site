<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_20-ea) on Fri Jan 09 18:07:25 GMT 2015 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>io.vertx.core.eventbus (Vert.x Core 3.0.0-SNAPSHOT API)</title>
<meta name="date" content="2015-01-09">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="io.vertx.core.eventbus (Vert.x Core 3.0.0-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/vertx/core/dns/impl/netty/decoder/record/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../io/vertx/core/eventbus/impl/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/vertx/core/eventbus/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;io.vertx.core.eventbus</h1>
<div class="docSummary">
<div class="block">= Vert.x Event Bus Manual
 :toc: right

 The <a href="../../../../io/vertx/core/eventbus/EventBus.html" title="interface in io.vertx.core.eventbus"><code>event bus</code></a> is the *nervous system* of Vert.x.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/EventBus.html" title="interface in io.vertx.core.eventbus">EventBus</a></td>
<td class="colLast">
<div class="block">A distributed lightweight event bus which can encompass multiple vert.x instances.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/Message.html" title="interface in io.vertx.core.eventbus">Message</a>&lt;T&gt;</td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/MessageCodec.html" title="interface in io.vertx.core.eventbus">MessageCodec</a>&lt;S,R&gt;</td>
<td class="colLast">
<div class="block">Instances of this class must be stateless as they will be used concurrently.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/MessageConsumer.html" title="interface in io.vertx.core.eventbus">MessageConsumer</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">An event bus consumer object representing a stream of message to an <a href="../../../../io/vertx/core/eventbus/EventBus.html" title="interface in io.vertx.core.eventbus"><code>EventBus</code></a> address that can
 be read from.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/MessageProducer.html" title="interface in io.vertx.core.eventbus">MessageProducer</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">Represents a stream of message that can be written to</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/DeliveryOptions.html" title="class in io.vertx.core.eventbus">DeliveryOptions</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Enum Summary table, listing enums, and an explanation">
<caption><span>Enum Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Enum</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/ReplyFailure.html" title="enum in io.vertx.core.eventbus">ReplyFailure</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Exception Summary table, listing exceptions, and an explanation">
<caption><span>Exception Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Exception</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../io/vertx/core/eventbus/ReplyException.html" title="class in io.vertx.core.eventbus">ReplyException</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package io.vertx.core.eventbus Description">Package io.vertx.core.eventbus Description</h2>
<div class="block">= Vert.x Event Bus Manual
 :toc: right

 The <a href="../../../../io/vertx/core/eventbus/EventBus.html" title="interface in io.vertx.core.eventbus"><code>event bus</code></a> is the *nervous system* of Vert.x.

 There is a single event bus instance for every Vert.x instance and it is obtained using the method <a href="../../../../io/vertx/core/Vertx.html#eventBus--"><code>Vertx.eventBus()</code></a>.

 The event bus allows different parts of your application to communicate with each other irrespective of what language they are written in,
 and whether they're in the same Vert.x instance, or in a different Vert.x instance.

 It can even be bridged to allow client side JavaScript running in a browser to communicate on the same event bus.

 The event bus forms a distributed peer-to-peer messaging system spanning multiple server nodes and multiple browsers.

 The event bus supports publish/subscribe, point to point, and request-response messaging.

 The event bus API is very simple. It basically involves registering handlers, unregistering handlers and
 sending and publishing messages.

 First some theory:

 == The Theory

 === Addressing

 Messages are sent on the event bus to an *address*.

 Vert.x doesn't bother with any fancy addressing schemes. In Vert.x an address is simply a string.
 Any string is valid. However it is wise to use some kind of scheme, e.g. using periods to demarcate a namespace.

 Some examples of valid addresses are +europe.news.feed1+, +acme.games.pacman+, +sausages+, and +X+.

 === Handlers

 Messages are received in handlers. You register a handler at an address.

 Many different handlers can be registered at the same address.

 A single handler can be registered at many different addresses.

 === Publish / subscribe messaging

 The event bus supports *publishing* messages.

 Messages are published to an address. Publishing means delivering the message
 to all handlers that are registered at that address.

 This is the familiar *publish/subscribe* messaging pattern.

 === Point to point and Request-Response messaging

 The event bus also supports *point to point* messaging.

 Messages are sent to an address. Vert.x will then route it to just one of the handlers registered at that address.

 If there is more than one handler registered at the address,
 one will be chosen using a non-strict round-robin algorithm.

 With point to point messaging, an optional reply handler can be specified when sending the message.

 When a message is received by a recipient, and has been handled, the recipient can optionally decide to reply to
 the message. If they do so the reply handler will be called.

 When the reply is received back at the sender, it too can be replied to. This can be repeated ad-infinitum,
 and allows a dialog to be set-up between two different verticles.

 This is a common messaging pattern called the *request-response* pattern.

 === Best-effort delivery

 Vert.x does it's best to deliver messages and won't consciously throw them away. This is called *best-effort* delivery.

 However, in case of failure of all or parts of the event bus, there is a possibility messages will be lost.

 If your application cares about lost messages, you should code your handlers to be idempotent, and your senders
 to retry after recovery.

 === Types of messages

 Out of the box Vert.x allows any primitive/simple type, String, or <a href="../../../../io/vertx/core/buffer/Buffer.html" title="interface in io.vertx.core.buffer"><code>buffers</code></a> to
 be sent as messages.

 However it's a convention and common practice in Vert.x to send messages as http://json.org/[JSON]

 JSON is very easy to create, read and parse in all the languages that Vert.x supports so it has become a kind of
 _lingua franca_ for Vert.x.

 However you are not forced to use JSON if you don't want to.

 The event bus is very flexible and also supports supports sending arbitrary objects over the event bus.
 You do this by defining a <a href="../../../../io/vertx/core/eventbus/MessageCodec.html" title="interface in io.vertx.core.eventbus"><code>codec</code></a> for the objects you want to send.

 == The Event Bus API

 Let's jump into the API

 === Registering Handlers

 This simplest way to register a handler is using <a href="../../../../io/vertx/core/eventbus/EventBus.html#consumer-java.lang.String-io.vertx.core.Handler-"><code>EventBus.consumer(String, io.vertx.core.Handler)</code></a>.
 Here's an example:

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example1-io.vertx.core.Vertx-"><code>EventBusExamples.example1(io.vertx.core.Vertx)</code></a>
 ----

 When a message arrives for your handler, your handler will be called, passing in the <a href="../../../../io/vertx/core/eventbus/Message.html" title="interface in io.vertx.core.eventbus"><code>message</code></a>.

 The object returned from call to +consumer()+ is an instance of <a href="../../../../io/vertx/core/eventbus/MessageConsumer.html" title="interface in io.vertx.core.eventbus"><code>MessageConsumer</code></a>

 This object can subsequently be used to unregister the handler, or use the handler as a stream.

 Alternatively you can use <a href="../../../../io/vertx/core/eventbus/EventBus.html#consumer-java.lang.String-io.vertx.core.Handler-"><code>EventBus.consumer(String, io.vertx.core.Handler)</code></a> to
 to return a +MessageConsumer+ with no handler set, and then set the handler on that. For example:

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example2-io.vertx.core.Vertx-"><code>EventBusExamples.example2(io.vertx.core.Vertx)</code></a>
 ----

 When registering a handler on a clustered event bus, it can take some time for the registration to reach all
 nodes of the cluster.

 If you want to be notified when this has completed, you can register a <a href="../../../../io/vertx/core/eventbus/MessageConsumer.html#completionHandler-io.vertx.core.Handler-"><code>completion handler</code></a>
 on the +MessageConsumer+ object.

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example3-io.vertx.core.eventbus.MessageConsumer-"><code>EventBusExamples.example3(io.vertx.core.eventbus.MessageConsumer&lt;java.lang.String&gt;)</code></a>
 ----

 === Un-registering Handlers

 To unregister a handler, call <a href="../../../../io/vertx/core/eventbus/MessageConsumer.html#unregister--"><code>MessageConsumer.unregister()</code></a>.

 If you are on a clustered event bus, un-registering can take some time to propagate across the nodes, if you want to
 be notified when this is complete use <a href="../../../../io/vertx/core/eventbus/MessageConsumer.html#unregister-io.vertx.core.Handler-"><code>MessageConsumer.unregister(io.vertx.core.Handler)</code></a>.

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example4-io.vertx.core.eventbus.MessageConsumer-"><code>EventBusExamples.example4(io.vertx.core.eventbus.MessageConsumer&lt;java.lang.String&gt;)</code></a>
 ----

 === Publishing messages

 Publishing a message is simple. Just use <a href="../../../../io/vertx/core/eventbus/EventBus.html#publish-java.lang.String-java.lang.Object-"><code>EventBus.publish(java.lang.String, java.lang.Object)</code></a> specifying the
 address to publish it to.

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example5-io.vertx.core.eventbus.EventBus-"><code>EventBusExamples.example5(io.vertx.core.eventbus.EventBus)</code></a>
 ----

 That message will then be delivered to all handlers registered against the address +news.uk.sport+.

 === Sending messages

 Sending a message will result in only one handler registered at the address receiving the message.
 This is the point to point messaging pattern. The handler is chosen in a non-strict round-robin fashion.

 You can send a message with <a href="../../../../io/vertx/core/eventbus/EventBus.html#send-java.lang.String-java.lang.Object-"><code>EventBus.send(java.lang.String, java.lang.Object)</code></a>

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example6-io.vertx.core.eventbus.EventBus-"><code>EventBusExamples.example6(io.vertx.core.eventbus.EventBus)</code></a>
 ----

 === Setting headers on messages

 Messages sent over the event bus can also contain headers. This can be specified by providing a
 <a href="../../../../io/vertx/core/eventbus/DeliveryOptions.html" title="class in io.vertx.core.eventbus"><code>DeliveryOptions</code></a> when sending or publishing:

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example7-io.vertx.core.eventbus.EventBus-"><code>EventBusExamples.example7(io.vertx.core.eventbus.EventBus)</code></a>
 ----

 === The Message object

 The object you receive in a message handler is a <a href="../../../../io/vertx/core/eventbus/Message.html" title="interface in io.vertx.core.eventbus"><code>Message</code></a>.

 The <a href="../../../../io/vertx/core/eventbus/Message.html#body--"><code>Message.body()</code></a> of the message corresponds to the object that was sent or published.

 The headers of the message are available with <a href="../../../../io/vertx/core/eventbus/Message.html#headers--"><code>Message.headers()</code></a>.

 === Replying to messages

 Sometimes after you send a message you want to receive a reply from the recipient.
 This is known as the *request-response pattern*.

 To do this you can specify a reply handler when sending the message.

 When the receiver receives the message they can reply to it by calling <a href="../../../../io/vertx/core/eventbus/Message.html#reply-java.lang.Object-"><code>Message.reply(java.lang.Object)</code></a>.

 When this happens it causes a reply to be sent back to the sender and the reply handler is invoked with the reply.

 An example will make this clear:

 The receiver:

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example8-io.vertx.core.eventbus.EventBus-"><code>EventBusExamples.example8(io.vertx.core.eventbus.EventBus)</code></a>
 ----

 The sender:

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example9-io.vertx.core.eventbus.EventBus-"><code>EventBusExamples.example9(io.vertx.core.eventbus.EventBus)</code></a>
 ----


 The replies themselves can also be replied to so you can create a dialog between two different parties
 consisting of multiple rounds.

 ## Sending with timeouts

 When sending a message with a reply handler you can specify a timeout in the <a href="../../../../io/vertx/core/eventbus/DeliveryOptions.html" title="class in io.vertx.core.eventbus"><code>DeliveryOptions</code></a>.

 If a reply is not received within that time, the reply handler will be called with a failure.

 The default timeout is 30 seconds.

 ## Send Failures

 Message sends can fail for other reasons, including:

 * There are no handlers available to send the message to
 * The recipient has explicitly failed the message using <a href="../../../../io/vertx/core/eventbus/Message.html#fail-int-java.lang.String-"><code>Message.fail(int, java.lang.String)</code></a>

 In all cases the reply handler will be called with the specific failure.

 ## Message Codecs

 You can send any object you like across the event bus if you define and register a <a href="../../../../io/vertx/core/eventbus/MessageCodec.html" title="interface in io.vertx.core.eventbus"><code>message codec</code></a> for it.

 Message codecs have a name and you specify that name in the <a href="../../../../io/vertx/core/eventbus/DeliveryOptions.html" title="class in io.vertx.core.eventbus"><code>DeliveryOptions</code></a>
 when sending or publishing the message:

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example10-io.vertx.core.eventbus.EventBus-io.vertx.core.eventbus.MessageCodec-"><code>EventBusExamples.example10(io.vertx.core.eventbus.EventBus, io.vertx.core.eventbus.MessageCodec)</code></a>
 ----

 If you always want the same codec to be used for a particular type then you can register a default codec for it, then
 you don't have to specify the codec on each send in the delivery options:

 [source,java]
 ----
 <a href="../../../../examples/EventBusExamples.html#example11-io.vertx.core.eventbus.EventBus-io.vertx.core.eventbus.MessageCodec-"><code>EventBusExamples.example11(io.vertx.core.eventbus.EventBus, io.vertx.core.eventbus.MessageCodec)</code></a>
 ----

 You unregister a message codec with <a href="../../../../io/vertx/core/eventbus/EventBus.html#unregisterCodec-java.lang.String-"><code>EventBus.unregisterCodec(java.lang.String)</code></a>.

 Message codecs don't always have to encode and decode as the same type. For example you can write a codec that
 allows a MyPOJO class to be sent, but when that message is sent to a handler it arrives as a MyOtherPOJO class.

 ## Clustered Event Bus

 The event bus doesn't just exist in a single Vert.x instance. By clustering different Vert.x instances together on
 your network they can form a single, distributed, event bus.</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/vertx/core/dns/impl/netty/decoder/record/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../io/vertx/core/eventbus/impl/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/vertx/core/eventbus/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2015. All rights reserved.</small></p>
</body>
</html>
